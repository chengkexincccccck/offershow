<!--
 * @Author: Chengkexin
 * @Date: 2022-07-03 23:25:07
 * @LastEditors: Chengkexin
 * @LastEditTime: 2022-08-05 20:25:48
 * @FilePath: /getOffer/chapter2/README.md
 * @Description: 
 * 
 * Copyright (c) 2022 by Chengkexin, All Rights Reserved. 
-->
# 第二章 面试需要的基础知识

### 2.1 面试官谈基础知识
1. 面向对象的特性、构造函数、析构函数、动态绑定
2. 设计模式、UML图
3. C++对内存的使用管理
4. 数据结构、算法、编程能力、部分数学知识、问题的分析和推理能力
5. 编程基本功、并发控制、算法、复杂度、语言的基本概念
6. 计算机系统、算法以及设计能力
7. 对OS的理解程度：内存管理、文件操作、程序性能、多线程、程序安全

### 2.2 编程语言
1. 复制构造函数不能单纯传值，需要使用常量引用A(const A& other)
2. 重点考察：构造函数、析构函数、运算符重载
3. 书籍推荐：《C++ Primer》、《Effective C++》、《深度探索C++对象模型》


### 2.3 数据结构
1. 为了解决数组空间效率不高的问题，人们设计实现了多种动态数组（STL中的vector：先开辟较小的空间，不够再扩充至原来的两倍，然后把数据复制到新的数组中并释放之前的内存），因此使用动态数组时要尽量减少改变数组容量大小的次数
2. C/C++中每个字符串都以'\0'作为结尾，需要注意避免越界
3. 为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时实际上会指向相同的内存空间。（单用常量初始化数组不是相同的内存空间）
4. 删除指针记得delete point，然后point=nullptr
5. 树的遍历（每种遍历都有递归和循环两种方式，一定要会用递归。另外还有宽度优先遍历）
   1. 前序遍历：根左右
   2. 中序遍历：左根右
   3. 后序遍历：左右根
6. 二叉树特例：
   1. 二叉搜索树：左子节点小于或等于根节点，右子节点大于或等于根节点，在该树中找节点的时间复杂度为O(logn)
   2. 堆
      1. 最大堆：根节点的值最大
      2. 最小堆：根节点的值最小
   3. 红黑树
      1. 把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶子结点的最长路径的长度不超过最短路径的两倍。
      2. C++的set、multiset、map、multimap都是基于红黑树实现
7. 栈：先进后出
8. 队列：先进先出
### 2.4 算法和数据操作
1. 排序和查找是面试时考察算法的重点，需要重点掌握二分查找、归并排序和快速排序
2. 要在二维数组（可能具体表现为迷宫或者棋盘等）上搜索路径，尝试使用回溯法——适合使用递归实现。只有当面试规定不能使用递归实现的时候再考虑使用栈来模拟
3. 求某个问题的最优解，且该问题可以分为多个子问题，可以尝试用动态规划。为了避免不必要的重复计算，把子问题的最优解先算出来存到数组中保存下来，然后基于子问题的解来计算大问题的解。
4. 动态规划的时候如果存在特殊的选择，应该考虑一下贪心算法
5. 递归代码简洁容易实现，但函数调用有时间和空间消耗。同时递归层级太多容易引起调用栈溢出。
6. 查找算法：顺序查找、二分查找、哈希查找、二叉排序树查找——重点**二分查找**
7. 如果在排序的数组中查找一个数字或者统计某个数字出现的次数，尽量选择二分查找
8. 需要会对比插入排序、冒泡排序、归并排序、快速排序等算法的优劣
9. 直接插入排序：适合少量元素的排序。基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动
10. 归并排序：采用分治法的典型应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
11. 快速排序：
    1.  从数列中挑出一个元素作为基准
    2.  重新排序数列，所有元素比基准小的放在基准前面，比基准大的放在基准后面
    3.  递归的把小于基准值元素的子数列和大于基准值的子数列排序

### 知识学习
- [X] sizeof(void)为什么是1
    答：内存不占空间无法使用其实例。至于占用多少内存由编译器决定。VS中空类型占用1字节
- [x] 构造函数和析构函数对sizeof的影响
    答：无影响，调用构造函数和析构函数只需要知道函数的地址，而函数地址只与类型相关
- [x] 虚函数内存占用
    答：C++编译器发现类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针（64位机器8字节）
- [x] 排序算法时间空间复杂度对比
    答：![图片](../images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
- [ ] 快速排序
- [x] 直接插入排序
    ```c++
   void insertSort(int data[], int n){
	int i, j, tmp;
	for (i = 1; i < n; ++i)		
	   {
		   if (data[i] < data[i - 1])
		   {
			   tmp = data[i];
			   data[i] = data[i - 1];
			   for (j = i - 2; j >= 0 && data[j] > tmp; --j)
			   {
				   data[j + 1] = data[j];
			   }
			   data[j + 1] = tmp;
		   }
	   }
   }
    ```
- [x] 归并排序
   ```c++
   void MergeSortArr(int arr[],int left,int mid,int right){//该函数同于将两个有序列合并成一个有序列，同时当两个有序列都为同一个元素是一样可以处理 
	   int i = left,j = mid + 1;//两个索引用来遍历两个有序列 
	   int k=0;//k用来遍历暂存数组temp 
	   int temp[right-left+1];//开一个数组暂时存放
	   while(i <=mid && j <= right){//对两个有序列进行遍历排序，有一个序列遍历完成结束循环 
		   if(arr[i] < arr[j])
			   temp[k++] = arr[i++];
		   else
		   	temp[k++] = arr[j++]; 
	   }
	   while(i <= mid){//将另外一个没有遍历完全的有序列全部插入到temp中 
	   	temp[k++] = arr[i++];
	   } 
	   while(j <= right){
	   	temp[k++] = arr[j++];
	   }
	   //！！这里需要注意循环的条件里面不能使用left因为left的值在改变 
	   for(i = 0;i < k;i++)//将排好序的序列更新到目标数组中 
	   	arr[left++] = temp[i];
   }
   //递归方法 
   void MergeSort(int arr[],int left,int right){
	   if(left == right)//如果两个划分为同一元素，递归结束 
	   	return ;
	   int mid = (left + right) / 2;//对本个划分再次进行划分 
	   MergeSort(arr, left, mid);//对左边的序列进行划分此条命令结束代表左边的序列已经有序 
	   MergeSort(arr, mid+1, right);//对右边的序列进行划分此条命令结束代表右边的序列已经有序 
	   MergeSortArr(arr, left, mid, right);//和并两个序列 
   } 
   //非递归方法 
   /*
   非递归方法需要两个个索引
   i表示每个划分个数
   j表示每个划分第一个元素
   三个遍历存放left mid right 
   */ 
   void MergeSort1(int arr[],int n){ 
	   int i,j;
	   int left,mid,right;
	   for(i=2; ;i *= 2){
	   	for(j = 0;j < n;j += i){
	   		left = j;
	   	//当一个划分中的元素大于等于2个是mid不会出错，当只有一个元素时，right必定是错误的则会导致mid错误 
	   		mid = (j + j + i - 1) / 2 < n? (j + j + i - 1) / 2 : n-1; 
	   		right = (j + i -1) < n? (j + i -1) : n-1;
	   		MergeSortArr(arr, left, mid, right);
	   	}
	   	if(i > n)
	   		break;
	   }
   } 
   ```
- [ ] 冒泡排序